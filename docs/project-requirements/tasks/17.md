# Task 17: Scoring and Decision Engine Tool

**Dependencies:** Task 3, Task 14

### Goal
Implement a Mastra tool that calculates weighted scores for supplier offers and generates human-readable decision explanations based on user-defined priorities.

### Implementation Context
**Files to Create:**
- `src/mastra/tools/scoring-tool.ts`

**Files to Modify:**
- `src/mastra/tools/index.ts` - Export the tool
- `src/mastra/agents/brand-agent.ts` - Add tool to brand agent

**Key Requirements:**
- Calculate weighted scores based on user-defined priorities
- Compare all 3 supplier offers objectively
- Generate human-readable decision rationale
- Handle missing or incomplete offer data gracefully

**Technical Notes:**
- Use `createTool` from `@mastra/core/tools`
- Scoring formula applies user priority weights
- Each criterion is normalized to 0-100 scale before weighting
- Tool output feeds into final decision generation

**Scoring Formula:**
```
total_score = (quality_score × quality_weight) + 
              (cost_score × cost_weight) + 
              (lead_time_score × lead_time_weight) + 
              (payment_terms_score × payment_terms_weight)
```

### Scope Definition
**Deliverables:**
- `scoringTool`: Mastra tool for evaluating supplier offers
- `generateDecisionTool`: Mastra tool for creating decision rationale
- Scoring algorithms for each criterion
- Integration with brand agent for final decision

**Scoring Criteria:**

| Criterion | Scoring Method | Best Score |
|-----------|---------------|------------|
| Quality | Direct from supplier rating (1-5 → 0-100) | Higher = better |
| Cost | Inverse of total cost (normalized) | Lower = better |
| Lead Time | Inverse of days (normalized) | Fewer days = better |
| Payment Terms | Cash flow impact analysis | Later payments = better |

**Exclusions:**
- Historical pricing analysis
- Supplier reliability scoring
- Risk assessment

### Implementation Steps

1. **Create scoring tool** (`src/mastra/tools/scoring-tool.ts`):
   ```typescript
   export const scoringTool = createTool({
     id: "score-supplier-offers",
     description: "Calculate weighted scores for all supplier offers based on user priorities",
     inputSchema: z.object({
       offers: z.array(z.object({
         supplierId: z.number(),
         qualityRating: z.number(),
         totalCost: z.number(),
         leadTimeDays: z.number(),
         paymentTerms: z.string(),
       })),
       priorities: z.object({
         quality: z.number(),
         cost: z.number(),
         leadTime: z.number(),
         paymentTerms: z.number(),
       }),
     }),
     outputSchema: z.object({
       scores: z.array(z.object({
         supplierId: z.number(),
         qualityScore: z.number(),
         costScore: z.number(),
         leadTimeScore: z.number(),
         paymentTermsScore: z.number(),
         totalScore: z.number(),
       })),
       winner: z.object({
         supplierId: z.number(),
         totalScore: z.number(),
         marginOverSecond: z.number(),
       }),
     }),
     execute: async ({ context }) => {
       // Implementation
     },
   });
   ```

2. **Implement criterion scoring:**
   ```typescript
   function scoreQuality(rating: number): number {
     // 1-5 scale → 0-100
     return ((rating - 1) / 4) * 100;
   }
   
   function scoreCost(cost: number, allCosts: number[]): number {
     // Inverse: lowest cost gets highest score
     const min = Math.min(...allCosts);
     const max = Math.max(...allCosts);
     return ((max - cost) / (max - min)) * 100;
   }
   
   function scoreLeadTime(days: number, allDays: number[]): number {
     // Inverse: fewer days gets higher score
     const min = Math.min(...allDays);
     const max = Math.max(...allDays);
     return ((max - days) / (max - min)) * 100;
   }
   
   function scorePaymentTerms(terms: string): number {
     // Later payments = higher score
     const termScores: Record<string, number> = {
       "100/0": 0,     // 100% upfront
       "50/50": 40,    // 50% upfront, 50% on delivery
       "30/70": 60,    // 30% upfront, 70% on delivery
       "33/33/33": 70, // Split into thirds
       "0/100": 100,   // 100% on delivery
     };
     return termScores[terms] ?? 50;
   }
   ```

3. **Create decision generation tool:**
   ```typescript
   export const generateDecisionTool = createTool({
     id: "generate-decision-rationale",
     description: "Generate human-readable explanation for supplier selection",
     inputSchema: z.object({
       scores: z.array(z.object({...})),
       winner: z.object({...}),
       priorities: z.object({...}),
     }),
     outputSchema: z.object({
       reasoning: z.string(),
       keyFactors: z.array(z.string()),
       tradeoffs: z.array(z.string()),
     }),
     execute: async ({ context }) => {
       // Generate natural language explanation
     },
   });
   ```

4. **Add tools to brand agent:**
   ```typescript
   const brandAgent = new Agent({
     // ...
     tools: { scoringTool, generateDecisionTool },
   });
   ```

5. **Test: Scoring produces expected results**
   - **Setup:** 3 offers with known values, priorities (quality: 40%, cost: 30%, lead_time: 20%, payment: 10%)
   - **Action:** Execute scoring tool
   - **Expect:** Supplier 2 wins when quality is prioritized

6. **Test: Decision rationale is coherent**
   - **Setup:** Scoring results with clear winner
   - **Action:** Execute decision generation tool
   - **Expect:** Returns reasoning that mentions the winning criteria

### Success Criteria
- Scoring tool correctly applies priority weights
- All criteria are normalized to 0-100 scale
- Winner is correctly identified
- Decision rationale is human-readable and accurate
- Tool handles edge cases (equal scores, missing data)

### Scope Constraint
Implement scoring and decision tools. Integration with workflow is in Task 15.

