# Task 19: Mastra Storage Integration with Convex

**Dependencies:** Task 1, Task 14

### Goal
Connect Mastra's storage layer to Convex for unified conversation persistence, enabling agent conversations to be stored in the same database as quotes, negotiations, and decisions.

### Implementation Context
**Files to Create:**
- `src/mastra/storage/convex-adapter.ts`

**Files to Modify:**
- `src/mastra/index.ts` - Configure storage

**Key Requirements:**
- Persist agent conversations to Convex Message table
- Load conversation history for context in subsequent calls
- Maintain compatibility with Mastra's storage interface
- Support conversation threading by negotiation_id

**Technical Notes:**
- Mastra uses a storage interface for persistence
- Default implementation uses LibSQL
- We'll create a custom adapter that uses Convex client
- Adapter must implement Mastra's storage interface methods

**Mastra Storage Interface:**
```typescript
interface MastraStorage {
  // Store agent message
  saveMessage(params: {
    agentId: string;
    threadId: string;
    message: Message;
  }): Promise<void>;

  // Retrieve conversation history
  getMessages(params: {
    agentId: string;
    threadId: string;
    limit?: number;
  }): Promise<Message[]>;

  // Clear conversation
  clearMessages(params: {
    agentId: string;
    threadId: string;
  }): Promise<void>;
}
```

### Scope Definition
**Deliverables:**
- `ConvexStorageAdapter`: Custom Mastra storage adapter using Convex
- Integration with existing Message table schema
- Thread-based conversation retrieval
- Automatic message persistence during agent calls

**Mapping to Convex Schema:**

| Mastra Concept | Convex Table | Field Mapping |
|----------------|--------------|---------------|
| threadId | Message.negotiation_id | Direct mapping |
| agentId | Message.sender | "brand" or "supplier" |
| message.content | Message.content | Direct mapping |
| message.timestamp | Message.timestamp | Direct mapping |

**Exclusions:**
- Memory features (cross-session learning)
- Vector storage for RAG
- Streaming message persistence

### Implementation Steps

1. **Create Convex adapter** (`src/mastra/storage/convex-adapter.ts`):
   ```typescript
   import { ConvexClient } from "convex/browser";
   import { api } from "../../convex/_generated/api";

   export class ConvexStorageAdapter {
     private client: ConvexClient;

     constructor(client: ConvexClient) {
       this.client = client;
     }

     async saveMessage(params: {
       agentId: string;
       threadId: string;
       message: { role: string; content: string };
     }): Promise<void> {
       await this.client.mutation(api.messages.create, {
         negotiation_id: params.threadId,
         sender: this.mapAgentIdToSender(params.agentId),
         content: params.message.content,
         timestamp: Date.now(),
       });
     }

     async getMessages(params: {
       agentId: string;
       threadId: string;
       limit?: number;
     }): Promise<Array<{ role: string; content: string }>> {
       const messages = await this.client.query(api.messages.getByNegotiation, {
         negotiation_id: params.threadId,
         limit: params.limit,
       });
       
       return messages.map((m) => ({
         role: this.mapSenderToRole(m.sender),
         content: m.content,
       }));
     }

     async clearMessages(params: {
       agentId: string;
       threadId: string;
     }): Promise<void> {
       await this.client.mutation(api.messages.deleteByNegotiation, {
         negotiation_id: params.threadId,
       });
     }

     private mapAgentIdToSender(agentId: string): "brand" | "supplier" | "user" {
       if (agentId.includes("brand")) return "brand";
       if (agentId.includes("supplier")) return "supplier";
       return "user";
     }

     private mapSenderToRole(sender: string): string {
       return sender === "user" ? "user" : "assistant";
     }
   }
   ```

2. **Create Convex mutations** for message persistence:
   ```typescript
   // convex/messages.ts
   export const create = mutation({
     args: {
       negotiation_id: v.string(),
       sender: v.string(),
       content: v.string(),
       timestamp: v.number(),
     },
     handler: async (ctx, args) => {
       return await ctx.db.insert("messages", args);
     },
   });

   export const getByNegotiation = query({
     args: {
       negotiation_id: v.string(),
       limit: v.optional(v.number()),
     },
     handler: async (ctx, args) => {
       const query = ctx.db
         .query("messages")
         .filter((q) => q.eq(q.field("negotiation_id"), args.negotiation_id))
         .order("asc");
       
       if (args.limit) {
         return await query.take(args.limit);
       }
       return await query.collect();
     },
   });
   ```

3. **Integrate adapter with Mastra instance:**
   ```typescript
   // src/mastra/index.ts
   import { ConvexStorageAdapter } from "./storage/convex-adapter";
   import { convexClient } from "../lib/convex";

   export const mastra = new Mastra({
     storage: new ConvexStorageAdapter(convexClient),
     agents,
     workflows,
   });
   ```

4. **Test: Messages are persisted to Convex**
   - **Setup:** Active negotiation with brand agent
   - **Action:** Agent generates response
   - **Expect:** Message appears in Convex messages table

5. **Test: Conversation history is loaded**
   - **Setup:** Existing messages in negotiation
   - **Action:** Agent generates with context
   - **Expect:** Agent references previous conversation content

### Success Criteria
- Agent messages are automatically persisted to Convex
- Conversation history is loaded for context
- Thread isolation works (messages don't leak between negotiations)
- Adapter handles Convex errors gracefully
- Message ordering is preserved

### Scope Constraint
Implement storage adapter for message persistence. Memory features and cross-session learning are out of scope.

