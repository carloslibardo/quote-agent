# Task 4: Create negotiation orchestration action for parallel supplier negotiations

**Dependencies:** Tasks 2, 3

### Goal
Implement the orchestration logic that coordinates parallel negotiations with all three suppliers, manages conversation flow, and handles user interventions.

### Implementation Context
**Files to Modify:**
- `src/server/negotiations.ts` (new)

**Key Requirements:**
- Start three parallel negotiations when quote status changes to "negotiating"
- Create negotiation records for each supplier (1, 2, 3)
- Coordinate message exchange between brand agent and supplier agents
- Support dynamic rounds until agreement or impasse
- Allow user intervention messages to be injected mid-negotiation
- Save all messages to database with proper sender identification

**Technical Notes:**
- Use Convex actions to orchestrate (can call other actions and mutations)
- Call `brandAgentNegotiate` and `supplierAgentRespond` actions from Task 3
- Use `Promise.all()` for parallel execution of supplier negotiations
- Save messages using mutations after each exchange
- Track negotiation status (active, completed, impasse) in database

**Simplicity Decisions:**
- Parallel execution without complex queue management
- Simple round-robin message exchange pattern
- No transaction rollback for partial failures (log and continue)

### Scope Definition
**Deliverables:**
- `startNegotiations` action: creates 3 negotiation records, initiates parallel conversations
- `continueNegotiation` action: processes next round of messages for active negotiations
- `addUserIntervention` mutation: adds user message to conversation, triggers brand agent response
- Message persistence logic for all conversation exchanges

**Exclusions:**
- Real-time progress updates (handled by polling/subscriptions)
- Negotiation pause/resume functionality (out of scope)

### Implementation Steps
1. Create `src/server/negotiations.ts` with action and mutation imports
2. Implement `startNegotiations` action that creates 3 negotiation records (one per supplier) with status "active"
3. For each negotiation, call `brandAgentNegotiate` to generate opening message, save to messages table
4. Implement `continueNegotiation` action that fetches active negotiations, gets conversation history
5. For each active negotiation, call `supplierAgentRespond` with conversation history, save supplier response
6. Call `brandAgentNegotiate` with updated history, save brand response
7. Check for agreement or impasse after each round, update negotiation status if complete
8. Implement `addUserIntervention` mutation that inserts user message, marks negotiation for brand agent response
9. **Test: Start negotiations creates 3 parallel conversations**
   - **Setup:** Quote with status "pending"
   - **Action:** Call startNegotiations with quote_id
   - **Expect:** 3 negotiation records created, 3 opening messages from brand agent saved
10. **Test: User intervention triggers brand agent response**
   - **Setup:** Active negotiation with 2 existing messages
   - **Action:** Call addUserIntervention with user guidance message
   - **Expect:** User message saved, brand agent generates new message incorporating guidance

### Success Criteria
- Three negotiations start in parallel when quote begins
- Brand agent and supplier agents exchange messages dynamically
- User intervention messages successfully injected into conversations
- All messages persisted to database with correct sender and timestamp
- Negotiation status updates when agreement or impasse reached
- Parallel execution completes without blocking

### Scope Constraint
Implement only negotiation orchestration. Do not implement decision evaluation logic.