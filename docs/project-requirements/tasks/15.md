# Task 15: Implement Negotiation Workflow with Mastra

**Dependencies:** Task 3, Task 14

### Goal
Create a Mastra workflow that orchestrates multi-agent negotiations, running parallel conversations with all three suppliers and coordinating the decision-making process.

### Implementation Context
**Files to Create:**
- `src/mastra/workflows/negotiation-workflow.ts`

**Files to Modify:**
- `src/mastra/workflows/index.ts` - Export the workflow
- `src/mastra/index.ts` - Register workflow

**Key Requirements:**
- Parallel execution of 3 supplier negotiations
- Dynamic negotiation rounds until agreement or impasse
- Maximum round limit (10 rounds) to prevent infinite loops
- State management for tracking negotiation progress
- Integration with Convex for message persistence

**Technical Notes:**
- Use `createWorkflow` and `createStep` from `@mastra/core/workflows`
- Use parallel step execution for concurrent supplier negotiations
- Steps can access Mastra instance for agent generation
- Workflow state tracks conversation history and status per supplier

**Mastra Workflow Pattern:**
```typescript
import { createWorkflow, createStep } from "@mastra/core/workflows";
import { z } from "zod";

const initiateNegotiationStep = createStep({
  id: "initiate-negotiation",
  inputSchema: z.object({
    supplierId: z.number(),
    quoteContext: z.object({...}),
  }),
  outputSchema: z.object({
    initialMessage: z.string(),
    negotiationId: z.string(),
  }),
  execute: async ({ inputData, mastra }) => {
    const agent = mastra.getAgent("brandAgent");
    const response = await agent.generate([...]);
    return { initialMessage: response.text, negotiationId: "..." };
  },
});

export const negotiationWorkflow = createWorkflow({
  id: "negotiation-workflow",
  inputSchema: z.object({
    quoteId: z.string(),
    products: z.array(...),
    priorities: z.object({...}),
  }),
  outputSchema: z.object({
    decision: z.object({...}),
  }),
})
  .then(initiateStep)
  .then(parallelNegotiationsStep)
  .then(evaluateOffersStep)
  .then(decisionStep);

negotiationWorkflow.commit();
```

### Scope Definition
**Deliverables:**
- `negotiationWorkflow`: Complete workflow orchestrating negotiations
- Steps:
  - `initializeNegotiations`: Create negotiation records in Convex
  - `parallelNegotiations`: Run 3 supplier negotiations concurrently
  - `negotiationRound`: Single round of brand â†” supplier exchange
  - `checkProgress`: Detect impasse or agreement
  - `evaluateOffers`: Score all final offers
  - `makeDecision`: Select winning supplier with reasoning

**Workflow State Schema:**
```typescript
const stateSchema = z.object({
  negotiations: z.array(z.object({
    supplierId: z.number(),
    status: z.enum(["active", "completed", "impasse"]),
    messages: z.array(z.object({
      sender: z.enum(["brand", "supplier", "user"]),
      content: z.string(),
      timestamp: z.number(),
    })),
    currentOffer: z.object({...}).optional(),
    roundCount: z.number(),
  })),
});
```

**Exclusions:**
- User intervention handling (handled via Convex mutations)
- Message persistence (delegated to Convex)
- UI real-time updates (handled by Convex subscriptions)

### Implementation Steps

1. **Define workflow input/output schemas:**
   ```typescript
   const inputSchema = z.object({
     quoteId: z.string(),
     products: z.array(z.object({
       productId: z.string(),
       quantity: z.number(),
     })),
     priorities: z.object({
       quality: z.number(),
       cost: z.number(),
       leadTime: z.number(),
       paymentTerms: z.number(),
     }),
     userNotes: z.string().optional(),
   });
   ```

2. **Create initialization step:**
   - Creates 3 negotiation records in Convex
   - Returns negotiation IDs and initial state

3. **Create negotiation round step:**
   - Brand agent sends message
   - Supplier agent responds
   - Check for agreement or impasse
   - Return updated conversation state

4. **Create parallel execution:**
   - Run 3 negotiation rounds concurrently
   - Each runs until completion or max rounds (10)

5. **Create evaluation step:**
   - Score each supplier's final offer
   - Apply user priority weights
   - Generate comparison data

6. **Create decision step:**
   - Select winning supplier
   - Generate reasoning text
   - Persist decision to Convex

7. **Test: Workflow completes with decision**
   - **Setup:** Valid quote with products and priorities
   - **Action:** Run negotiation workflow
   - **Expect:** Returns decision with selected supplier and reasoning

8. **Test: Impasse detection works**
   - **Setup:** Configure agents to never agree
   - **Action:** Run negotiation workflow
   - **Expect:** After 10 rounds, negotiations marked as impasse

### Success Criteria
- Workflow runs all 3 supplier negotiations in parallel
- Each negotiation runs dynamically until agreement or impasse
- Maximum round limit (10) prevents infinite loops
- All steps have proper input/output validation
- Workflow state is properly maintained across steps
- Decision is generated after all negotiations complete

### Scope Constraint
Implement the workflow orchestration. Agent implementations are in Task 3, and storage integration is in Task 19.

